
"Find the cross-links for Unicode character data."

i1@(Unicode CharacterProperties traits) equals: i2@(Unicode CharacterProperties traits)
[
  i1 isNil \/ i2 isNil ifTrue: [^ False].
  i1 GeneralCategory = i2 GeneralCategory
    /\ [i1 CanonicalCombiningClass = i2 CanonicalCombiningClass]
    /\ [i1 BidiClass = i2 BidiClass]
    /\ [i1 BidiMirrored = i2 BidiMirrored]
    /\ [i1 DecimalDigitValue = i2 DecimalDigitValue]
    /\ [i1 DigitValue = i2 DigitValue]
    /\ [i1 NumericValue = i2 NumericValue]
    /\ [i1 DecompositionType = i2 DecompositionType]
    /\ [i1 DecompositionMapping = i2 DecompositionMapping]
    /\ [i1 Compositions = i2 Compositions]
    /\ [i1 SimpleUppercaseMapping = i2 SimpleUppercaseMapping]
    /\ [i1 SimpleLowercaseMapping = i2 SimpleLowercaseMapping]
    /\ [i1 SimpleTitlecaseMapping = i2 SimpleTitlecaseMapping]
].

a1@(Array traits) equals: a2@(Repetition traits) [False].
a1@(Repetition traits) equals: _ [False].
a1@(Repetition traits) equals: a2@(Repetition traits) [False]. "We don't need obsolete links."
_@Nil equals: _@Nil [False]. "We don't need obsolete links."

a1@(Array traits) equals: a2@(Array traits)
[
  a1 with: a2 do:
    [| :item1 :item2 |  
     item1 isNil
       \/ [item2 isNil]
       \/ [(item1 equals: item2) not]
       ifTrue: [^ False]]. "We don't need obsolete links."
  True
].

c@(Sequence traits) findDup: obj below: end
[
  0 below: end do: [| :index |
     ((c at: index) equals: obj) ifTrue: [^ index]].
].

c@(Sequence traits) findDup: obj
[
  c indexOfFirstSatisfying: #(equals: obj) `er
].

buffer@(Sequence traits) findDuplicate: obj 
             nonDuplicates: nondup
             into: target
             dupHash: duphash
             nonDupHash: nonduphash
             codePoint: codepoint
"Check buffer for duplicates of obj. If none is found, check buffer of
non-duplicates. If not found there either, add obj to non-duplicates
buffer. If found, move the found one from non-duplicates to duplicates. 
Always when a duplicate is found, put the link between them to target."
[
  (buffer findDup: obj)
    ifNil:
      [(nondup findDup: obj)
         ifNil: [nondup add: obj.
             nonduphash add: nondup indexLast -> codepoint.
             Console ; '.']
         ifNotNil:
           [| :nd |
            buffer add: (nondup at: nd).
            duphash add: buffer indexLast -> codepoint.
            nondup remove: nd.
            target add: codepoint -> (nonduphash at: nd).
            Console ; '!']]
    ifNotNilDo:
      [| :dup |
       target add: codepoint -> (duphash at: dup).
       Console ; 'o'.
       dup]
].

flat@(Unicode Trie traits) generatePhase2LinksInto: target
[| flat duphash nonduphash codePoint displayCounter |
 displayCounter := 0.
 duphash := Dictionary new.
 nonduphash := Dictionary new.
 0 upTo: 16r10FFFD do: [| :codePoint |
   (flat atCode: codePoint) ifNotNilDo:
     [| :current |
      CharacterData Unicode DuplicateBuffer
     findDuplicate: current
     nonDuplicates: CharacterData Unicode NonDuplicateBuffer
     into: target
     dupHash: duphash
     nonDupHash: nonduphash
     codePoint: codePoint.
      (displayCounter += 1) > 70 ifTrue: 
    [Console ; '\n'.
     displayCounter := 0]].
   ].
].

table@(Unicode Trie traits) generatePhase1Links
[| links current |
 links := ExtensibleArray new.
 table contents
   doWithIndex:  [| :each :index |
          current := table at: index.
          current ifNotNil: [
            (table findDup: current below: index)
                      ifNotNilDo: [| :dup | links add: index -> dup]]].
 links
].

"Reading of cross-links is in unicode-data.slate".

links@(Sequence traits) writeCrosslinksTo: targetFileName
[| targetStream byte1 byte2 byte3 c |
 File withOpenNamed: targetFileName
   do: [| :target |
    targetStream := target writer.
    links
      do: [| :each |
            c := each key.
            byte1 := c bitAnd:  16rFF.
        byte2 := (c bitAnd: 16rFF00) bitShift: -8.
        byte3 := (c bitAnd: 16rFF0000) bitShift: -16.
        targetStream nextPut: byte1.
        targetStream nextPut: byte2.
        targetStream nextPut: byte3.
        c := each value.
            byte1 := c bitAnd:  16rFF.
        byte2 := (c bitAnd: 16rFF00) bitShift: -8.
        byte3 := (c bitAnd: 16rFF0000) bitShift: -16.
        targetStream nextPut: byte1.
        targetStream nextPut: byte2.
        targetStream nextPut: byte3]
      ] &mode: File CreateWrite.
].

_@here generateCrosslinks
[| compositions |
  inform: 'Generating cross-links.'.
  CharacterData Unicode
    `>> [addSlot: #FlatTable valued: Unicode Trie new.
     addSlot: #Links2 valued: ExtensibleArray new.
     addSlot: #Links1 valued: ExtensibleArray new.
     addSlot: #DuplicateBuffer valued: ExtensibleArray new.
     addSlot: #NonDuplicateBuffer valued: ExtensibleArray new.
     addSlot: #Compositions valued: ExtensibleArray new. ].

  compositions := ExtensibleArray new.
  inform: 'Building flat table.'.
  CharacterData Unicode FlatTable 
    buildTableWithLinks: Nil
    compositions: CharacterData Unicode Compositions.

  inform: 'Adding compositions.'.
  CharacterData Unicode FlatTable addCompositionsFrom: CharacterData Unicode Compositions.

  inform: 'Generating phase 2 links.\n'.
  CharacterData Unicode FlatTable 
                generatePhase2LinksInto: CharacterData Unicode Links2.

  inform: '\nSaving phase 2 links to \'src/i18n/Links2.data\''.
  CharacterData Unicode Links2 writeCrosslinksTo: 'src/i18n/Links2.data'.

  inform: 'Generating phase 1 links.\n'.
  CharacterData Unicode Links1 := CharacterData Unicode FlatTable generatePhase1Links.

  inform: 'Saving phase 1 links for properties to \'src/i18n/Links1.data'.
  CharacterData Unicode Links1 writeCrosslinksTo: 'src/i18n/Links1.data'.

  inform: 'Ready.'.
].
