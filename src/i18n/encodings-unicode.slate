
"This file contains the basis for unicode encoded strings."

prototypes define: #UnicodeCharacter &parents: {EncodedCharacter}.
prototypes define: #UnicodeSubset &parents: {Cloneable}.

prototypes ensureNamespace: #Unicode.
CharacterData ensureNamespace: #Unicode.

"EncodedString is Unicode by default. encodings-unicode.slate must be the
first encoding-file to be loaded."
EncodedString elementType := UnicodeCharacter.

prototypes define: #UnicodeString &parents: {EncodedString}
 &slots: {#contents -> #{}}.

s@(UnicodeString traits) new &capacity: n
[s clone `>> [contents := s contents new &capacity: n. ]].

s@(UnicodeString traits) size
[
  s contents size
].

s@(UnicodeString traits) isEmpty
[
  s contents isEmpty
].

s@(UnicodeString traits) at: n
[
  s contents at: n
].

s@(UnicodeString traits) at: n put: char
[
  s contents at: n put: char
].

prototypes define: #SmallUnicodeString &parents: {UnicodeString}
  &slots: {#elementType -> UnicodeCharacter.
       #bytes1 -> ByteArray new.
       #bytes2 -> ByteArray new.
       #bytes3 -> ByteArray new}.

unicode@(Integer traits) as: c@(UnicodeCharacter traits)
[
 c newCode: unicode
].

u@(UnicodeCharacter traits) as: _@(Integer traits)
[
  u code
].

s@(SmallUnicodeString traits) new &capacity: n
[
 s clone `setting: #{#bytes1. #bytes2. #bytes3}
   to: {s bytes1 newSize: n. s bytes2 newSize: n. s bytes3 newSize: n}
].

s@(SmallUnicodeString traits) size
[
  s bytes1 size
].

s@(SmallUnicodeString traits) isEmpty
[
  s bytes1 isEmpty
].

s@(SmallUnicodeString traits) at: n
[
  (((s bytes1 at: n)
      bitOr: ((s bytes2 at: n) bitShift: 8))
     bitOr: ((s bytes3 at: n) bitShift: 16)) as: s elementType
].

s@(SmallUnicodeString traits) at: n put: char
[| c byte1 byte2 byte3 value |
 c: char code.
 byte1: (c bitAnd:  16rFF).
 byte2: ((c bitAnd: 16rFF00) bitShift: -8).
 byte3: ((c bitAnd: 16rFF0000) bitShift: -16).
 s bytes1 at: n put: byte1.
 s bytes2 at: n put: byte2.
 s bytes3 at: n put: byte3.
 s
].

s@(SmallUnicodeString traits) do: block
"Avoids a direct do: delegation, to use its own at: implementation."
[
  s bytes1 doWithIndex: [| :_ :index | block applyTo: {s at: index}]
].

u@Unicode addSubset: name
[u define: name &parents: {UnicodeSubset}].

[| :name | Unicode addSubset: name] for: #{
  #General.
  #AlphabeticPresentations.
  #Arabic.
  #ArabicPresentationsA.
  #ArabicPresentationsB.
  #Armenian.
  #Arrows.
  #Bengali.
  #BlockElements.
  #BoxDrawing.
  #Braille.
  #Buhid.
  #ByzantineMusicals.
  #CanadianAboriginal.
  #Cherokee.
  #CombiningDiacritical.
  #CombiningDiacriticalForSymbols.
  #CombiningHalfMarks.
  #ControlPictures.
  #CurrencySymbols.
  #Cyrillic.
  #Deseret.
  #Devanagari.
  #Dingbats.
  #EnclosedAlnums.
  #Ethiopic.
  #GeneralPunctuation.
  #GeometricShapes.
  #Georgian.
  #Gothic.
  #Greek.
  #GreekExtended.
  #Gujarati.
  #Gurmukhi.
  #Hanunoo.
  #Hebrew.
  #IPA.
  #Japanese.
  #Kannada.
  #Khmer.
  #Korean.
  #Lao.
  #Latin.
  #LatinExtendedAB.
  #LatinExtendedAdditional.
  #LetterlikeSymbols.
  #Malayalam.
  #MathAlnumSymbols.
  #MathOperators.
  #MiscMathSymbolsA.
  #MiscMathSymbolsB.
  #MiscSymbols.
  #MiscTechnical.
  #Mongolian.
  #MusicalSymbols.
  #Myanmar.
  #NumberForms.
  #OCRs.
  #Ogham.
  #OldItalic.
  #Oriya.
  #Runic.
  #SimplifiedChinese.
  #Sinhala.
  #SpacingModifiers.
  #SuperAndSubscript.
  #SupplementalArrowsA.
  #SupplementalArrowsB.
  #SupplementalMathOperators.
  #Syriac.
  #Tagalog.
  #Tagbanwa.
  #Tags.
  #Tamil.
  #Telugu.
  #Thaana.
  #Thai.
  #Tibetan.
  #TraditionalChinese.
  #Vietnamese.
  #YiRadicals.
  #YiSyllables
}.

UnicodeCharacter traits compareAndHashUsingSlots: #{#code}.

ns@Unicode subsetAt: i@(Integer traits) &kanjiClass: kanjiClass
"Find the subset of Unicode characters a character belongs to.
This is localized."
[
  kanjiClass `defaultsTo: CurrentLocale KanjiClass.
  i // 4096 caseOf: {
    0 -> [ns subsetFor0: i].
    1 -> [ns subsetFor1: i].
    2 -> [(i >= 16r2E80
             ifTrue: [ns subsetForKanjiClass: kanjiClass]
             ifFalse: [ns subsetFor2: i])].
    3 -> [ns subsetForKanjiClass: kanjiClass].
    4 -> [ns subsetForKanjiClass: kanjiClass].
    5 -> [ns subsetForKanjiClass: kanjiClass].
    6 -> [ns subsetForKanjiClass: kanjiClass].
    7 -> [ns subsetForKanjiClass: kanjiClass].
    8 -> [ns subsetForKanjiClass: kanjiClass].
    9 -> [ns subsetForKanjiClass: kanjiClass].
    10 -> [ns subsetFor10: i].
    11 -> [ns Korean].
    12 -> [ns Korean].
    13 -> [ns subsetFor13: i].
    14 -> [ns General].
    15 -> [i <= 16rF8FF ifTrue: [^ ns General].
       i <= 16rFAFF ifTrue: [^ ns subsetForKanjiClass: kanjiClass].
       i <= 16rFB4F ifTrue: [^ ns AlphabeticPresentations].
       i <= 16rFDFF ifTrue: [^ ns ArabicPresentationsA].
       i <= 16rFE0F ifTrue: [^ ns General].
       i <= 16rFE2F ifTrue: [^ ns CombiningHalfMarks].
       i <= 16rFE4F ifTrue: [^ ns General].
       i <= 16rFE6F ifTrue: [^ ns General].
       i <= 16rFEFF ifTrue: [^ ns ArabicPresentationsB].
       i <= 16rFFEF ifTrue: [^ ns subsetForKanjiClass: kanjiClass].
       ns General]
  } otherwise:
    [(i between: 16r10300 and: 16r1032F) ifTrue: [^ ns OldItalic].
     i <= 16r1034F ifTrue: [^ ns Gothic].
     (i between: 16r10400 and: 16r1044F) ifTrue: [^ ns Deseret].
     i <= 16r1CFFF ifTrue: [^ ns General].
     i <= 16r1D0FF ifTrue: [^ ns ByzantineMusicals].
     i <= 16r1D3FF ifTrue: [^ ns General].
     i <= 16r1D7FF ifTrue: [^ ns MathAlnumSymbols].
     (i between: 16r20000 and: 16r2FA1F) ifTrue: [^ ns subsetForKanjiClass: kanjiClass].
     ns General]
].

ns@Unicode subsetForKanjiClass: kanjiClass@(Symbol traits)
[
  kanjiClass caseOf: {
    #Japanese -> [ns Japanese].
    #Korean -> [ns Korean].
    #SimplifiedChinese -> [ns SimplifiedChinese]".
    #Taiwanese -> [ns TraditionalChinese].
    #Vietnamese -> [ns Vietnamese]."
  } otherwise: [ns General]
].

ns@Unicode subsetFor0: i
[
  i < 16r780 ifTrue:
    [i < 16r100 ifTrue: [^ ns Latin].
     i <= 16r24F ifTrue: [^ ns LatinExtendedAB].
     i <= 16r2AF ifTrue: [^ ns IPA].
     i <= 16r2FF ifTrue: [^ ns SpacingModifiers].
     i <= 16r36F ifTrue: [^ ns CombiningDiacritical].
     i <= 16r3FF ifTrue: [^ ns Greek].
     i <= 16r52F ifTrue: [^ ns Cyrillic].
     i <= 16r58F ifTrue: [^ ns Armenian].
     i <= 16r5FF ifTrue: [^ ns Hebrew].
     i <= 16r6FF ifTrue: [^ ns Arabic].
     i <= 16r74F ifTrue: [^ ns Syriac].
     ^ ns General].
  i <= 16r7BF ifTrue: [^ ns Thaana].
  i < 16r900 ifTrue: [^ ns General].
  i <= 16r97F ifTrue: [^ ns Devanagari].
  i <= 16r9FF ifTrue: [^ ns Bengali].
  i <= 16rA7F ifTrue: [^ ns Gurmukhi].
  i <= 16rAFF ifTrue: [^ ns Gujarati].
  i <= 16rB7F ifTrue: [^ ns Oriya].
  i <= 16rBFF ifTrue: [^ ns Tamil].
  i <= 16rC7F ifTrue: [^ ns Telugu].
  i <= 16rCFF ifTrue: [^ ns Kannada].
  i <= 16rD7F ifTrue: [^ ns Malayalam].
  i <= 16rDFF ifTrue: [^ ns Sinhala].
  i <= 16rE7F ifTrue: [^ ns Thai].
  i <= 16rEFF ifTrue: [^ ns Lao].
  i <= 16rFFF ifTrue: [^ ns Tibetan].
  ns General
].

ns@Unicode subsetFor1: i
[
  i < 16r1700 ifTrue: 
    [i <= 16r109F ifTrue: [^ ns Myanmar].
     i <= 16r10FF ifTrue: [^ ns Georgian].
     i <= 16r11FF ifTrue: [^ ns General].
     i <= 16r137F ifTrue: [^ ns Ethiopic].
     i <= 16r13FF ifTrue: [^ ns Cherokee].
     i <= 16r167F ifTrue: [^ ns CanadianAboriginal].
     i <= 16r169F ifTrue: [^ ns Ogham].
     i <= 16r16FF ifTrue: [^ ns Runic].
     ^ ns General].
 i <= 16r171F ifTrue: [^ ns Tagalog].
 i <= 16r173F ifTrue: [^ ns Hanunoo].
 i <= 16r175F ifTrue: [^ ns Buhid].
 i <= 16r177F ifTrue: [^ ns Tagbanwa].
 i <= 16r17FF ifTrue: [^ ns Khmer].
 i <= 16r18AF ifTrue: [^ ns Mongolian].
 i <= 16r1EFF ifTrue: [^ ns LatinExtendedAdditional].
 i <= 16r1FFF ifTrue: [^ ns GreekExtended].
 ns General
].

ns@Unicode subsetFor2: i@(Integer traits)
[
  i < 16r2600 ifTrue: 
    [i <= 16r206F ifTrue: [^ ns GeneralPunctuation].
     i <= 16r209F ifTrue: [^ ns SuperAndSubscript].
     i <= 16r20CF ifTrue: [^ ns CurrencySymbols].
     i <= 16r20FF ifTrue: [^ ns CombiningDiacriticalForSymbols].
     i <= 16r214F ifTrue: [^ ns LetterlikeSymbols].
     i <= 16r218F ifTrue: [^ ns NumberForms].
     i <= 16r21FF ifTrue: [^ ns Arrows].
     i <= 16r22FF ifTrue: [^ ns MathOperators].
     i <= 16r23FF ifTrue: [^ ns MiscTechnical].
     i <= 16r243F ifTrue: [^ ns ControlPictures].
     i <= 16r245F ifTrue: [^ ns OCRs].
     i <= 16r24FF ifTrue: [^ ns EnclosedAlnums].
     i <= 16r257F ifTrue: [^ ns BoxDrawing].
     i <= 16r259F ifTrue: [^ ns BlockElements].
     i <= 16r25FF ifTrue: [^ ns GeometricShapes].
     ^ ns General].
  i <= 16r26FF ifTrue: [^ ns MiscSymbols].
  i <= 16r27BF ifTrue: [^ ns Dingbats].
  i <= 16r27EF ifTrue: [^ ns MiscMathSymbolsA].
  i <= 16r27FF ifTrue: [^ ns SupplementalArrowsA].
  i <= 16r28FF ifTrue: [^ ns Braille].
  i <= 16r297F ifTrue: [^ ns SupplementalArrowsB].
  i <= 16r29FF ifTrue: [^ ns MiscMathSymbolsB].
  i <= 16r2AFF ifTrue: [^ ns SupplementalMathOperators].
  ns General
].   

ns@Unicode subsetFor10: i
[
  i >= 16rAC00 ifTrue: [^ ns Korean].
  i <= 16rA48F ifTrue: [^ ns YiSyllables].
  i <= 16rA4CF ifTrue: [^ ns YiRadicals].
  ns General
].

ns@Unicode subsetFor13: i
[
  i <= 16rD7AF ifTrue: [^ ns Korean].
  ns General
].

_@(UnicodeCharacter traits) codeRange
[0 to: 16r10FFFF].

c@(UnicodeCharacter traits) allCharacters
"Answers all unicode characters. Use with caution."
[
  c codeRange collect: [| :code | code as: c]
].

_@(UnicodeString traits) accepts: _@(UnicodeCharacter traits)
[True].

c@(UnicodeCharacter traits) is: ss@(UnicodeSubset traits)
[
  (Unicode subsetAt: c) is: ss
].

CharacterData define: #MathematicalPluses
          &builder: [{16r2B as: UnicodeCharacter}].   "$+"
CharacterData define: #MathematicalMinuses
          &builder: [{16r2D as: UnicodeCharacter.    "$-"
             16r2212 as: UnicodeCharacter.  "Minus sign"
             16rFE63 as: UnicodeCharacter.  "Small minus"
             16rFF0D as: UnicodeCharacter}]. "Full-width minus"
CharacterData define: #MathematicalPeriods
          &builder: [{16r2E as: UnicodeCharacter}].   "$."
"TODO: add more, if there are any"
CharacterData define: #MathematicalExponents
              &builder: [{16r52 as: UnicodeCharacter.
                          16r72 as: UnicodeCharacter}].
CharacterData define: #ThousandsSeparators
              &builder: [{16r5F as: UnicodeCharacter.      "$_"
                          16r66C as: UnicodeCharacter}].   "Arabian thousands separator"

l@(ReadStream traits) readInteger &radix: radix &separators: separators
"The general method for building integers from the raw characters, with a
radix (number of digits) parameter. The separators are characters to be
ignored."
[| number |
  separators `defaultsTo: CharacterData ThousandsSeparators.
  radix `defaultsTo: 10.
  number := 0.
  [l isAtEnd not
     /\ [(l peek isDigit &radix: radix)
       \/ [separators includes: l peek]]]
    whileTrue:
      [| c |
       ((c := l next) isDigit &radix: radix) ifTrue:
         [number := number * radix + (c toDigit &radix: radix)]].
  number
].

l@(ReadStream traits) readNumber &separators: separators
"The overall routine for building numbers.
FIXME: add checks that numbers are of same script"
[| token number sign c pluses minuses |
  separators `defaultsTo: CharacterData ThousandsSeparators.
  "Assign the default sign, then override it based on the presence of an
  explicit sign character."
  sign := 1.
  c := l peek.
  (CharacterData MathematicalPluses includes: c)
    \/ [CharacterData MathematicalMinuses includes: c]
    ifTrue: [(CharacterData MathematicalMinuses includes: c) 
        ifTrue: [sign := -1].
         l next].
  "Now read in all the continuous string of digits possible as an integer."
  number := (l readInteger &radix: 10).
  "Reaching the end of the lexing stream just finalizes the process."
  l isAtEnd ifTrue: [^ (sign * number)].
  "Conditionalize on the next character: it may set up a radix or a decimal."
  c := l next.
  (CharacterData MathematicalExponents includes: c)
    ifTrue:
      [number := l readInteger &radix: number]
    ifFalse:
      [(CharacterData MathematicalPeriods includes: c)
     /\ [l isAtEnd not] /\ [l peek isDigit]
         ifTrue:
           [number := (number as: Float) + (l readMantissa &separators: separators).
            l isAtEnd
              ifTrue: [^ (sign * number)].
            c := l next].
       c = (16r65 as: UnicodeCharacter) \/ [c = (16r45 as: UnicodeCharacter)] "e or E"
         ifTrue:
           [number := (number as: Float) * (10.0 raisedTo: l readExponent)]].
  sign * number
].

l@(ReadStream traits) readMantissa &separators: separators
"Build a floating-point number's fractional part."
"FIXME: the mantissa should probably also follow the same radix"
[| number place |
  separators `defaultsTo: CharacterData ThousandsSeparators.
  number := 0.
  place := 1.
  [l isAtEnd not /\ [l peek isDigit \/ [separators includes: l peek]]]
    whileTrue:
      [| c |
        c := l next.
    c toDigit.
        c isDigit
          ifTrue:
            [number := number * 10 + c toDigit.
         place *= 10]
      ].
  (number as: Float) / (place as: Float)
].

l@(ReadStream traits) readExponent
"Build a floating-point number's exponent as an integer."
"FIXME: the exponent should probably also follow the same radix"
[| sign c |
  sign := 1.
  (CharacterData MathematicalPluses includes: (c := l peek))
    ifTrue: [l next]
    ifFalse: [(CharacterData MathematicalMinuses includes: c) ifTrue:
                [sign := -1. l next]].
  sign * l readInteger
].

c@(UnicodeString traits) as: _@(Number traits) &radix: radix
[
  c reader readNumber &radix: radix
].

c@(UnicodeString traits) as: _@(Integer traits) &radix: radix
[
  (c as: Number) as: Integer
].

c@(UnicodeCharacter traits) as: _@(ASCIIString Character traits)
[
  c code < 16r100
   ifTrue: [c code as: ASCIIString Character]
   ifFalse: [0] "FIXME: what should this be?"
].

c@(ASCIIString Character traits) as: u@(UnicodeCharacter traits)
[u newCode: c code].

c@(UnicodeCharacter traits) as: s@(UnicodeString traits)
[(s newSize: 1) `>> [at: 0 put: c. ]].

n@(Integer traits) as: s@(UnicodeString traits)
[n printString as: s].

f@(Float traits) as: s@(UnicodeString traits)
[f printString as: s].

c@(UnicodeCharacter traits) cr [16rA as: c].

c@(UnicodeCharacter traits) tab [16r9 as: c].

c@(UnicodeCharacter traits) space [16r20 as: c].

c@(UnicodeCharacter traits) stringEscape [16r5C as: c].

s1@(UnicodeString traits) lexicographicallyCompare: s2@(UnicodeString traits)
"Answer a sign of comparing the two strings' characters in order."
"NOTE: this works only for basic latin characters. This is not really
Unicode-aware, and should be fixed."
[
  s1 toUppercase with: s2 toUppercase do:
    [| :c1 :c2 cmp |
     (cmp := c1 code <=> c2 code) isZero ifFalse: [^ cmp]].
  s1 size <=> s2 size
].
